第一个文件夹中的代码：这个是用R语言从GEO中下载数据

#下面这六行是安装相应包的代码，无脑运行就行了。

if(!requireNamespace("BiocManager",quietly = T))

  install.packages("BiocManager")

if(!requireNamespace("GEOquery",quietly = T))

  BiocManager::install("GEOquery")

if(!requireNamespace("limma",quietly = T))

  BiocManager::install("limma",force = TRUE)

if(!requireNamespace("tidyverse",quietly = T))

  install.packages("tidyverse",force = TRUE)



library(tidyverse)

library(limma)

library(GEOquery)





if (!file.exists("GSE19804_eSet.Rdata")) {

  GEO_file <- getGEO('GSE19804',#需要下载的series

                     destdir = 'F:/Graduation thesis',#设置文件保存路径

                     getGPL = T #下载平台文件

  )

  save(GEO_file, file = "GSE19804_eSet.Rdata")#将下载下来的文件保存为我们可以处理的格式

}



load("GSE19804_eSet.Rdata")#将更改好格式并保存好的的数据加载到这里


GEO_file[[1]]#提取GEO_file中第一个数据

exp <- exprs(GEO_file[[1]])#提取数据中的样本基因表达矩阵

plate <- fData(GEO_file[[1]])#提取数据中的平台信息

clinical <- pData(GEO_file[[1]])#提取数据中的样本临床信息（比如：年龄、性别、是否存活等等）

#看一下数据分布

exp <- as.matrix(exp)

boxplot(exp)



#两种方式进行基因注释
#第1种方式
if(!requireNamespace("hgu133plus2.db",quietly = T))
  BiocManager::install("hgu133plus2.db")
library(hgu133plus2.db)#引用包

ID <- toTable(hgu133plus2SYMBOL)#提取GPL3921芯片平台的探针ID和对应的基因
colnames(ID)[1] <- 'probe_id'
exp <- as.data.frame(exp)
exp$probe_id <- rownames(exp)#将探针ID添加到dat1表达矩阵的新的一列
exp <- merge(exp, ID, by = 'probe_id')#merge()函数将dat1的探针id与芯片平台探针id相匹配，合并到dat1
exp[exp == ""] <- NA#将空白负值NA
exp <- na.omit(exp)#删除GENE_SYBOL缺失的数据
exp <- as.data.frame(exp)
write.csv(exp, "exp.csv")
exp <- read.csv("exp.csv", row.names = 1)
exp[exp < 0] <- 0

#############几种处理重复基因的方式，下面的方式选择一种就行了##################
table(duplicated(exp$symbol))#看一下有多少重复
#第一种，将重复基因取平均值
exp1 <- avereps(exp, ID = exp$symbol)
exp1 <- as.data.frame(exp1)
rownames(exp1) <- exp1$symbol#加上行名
exp1 <- exp1[,-c(1,ncol(exp1))]#将多余列的数据剔除
write.csv(exp1, "exp_average.csv")#保存为csv格式

#第二种，取重复基因中的最大值
exp2 <- aggregate(exp, by=list(exp$symbol), FUN = max, na.rm=T)
rownames(exp2) <- exp2$Group.1#加上行名
exp2 <- exp2[,-c(1,2,ncol(exp2))]#将多余列的数据剔除
write.csv(exp2, "exp_max.csv")#保存为csv格式

#第三种，取重复基因中的最小值
exp3 <- aggregate(exp, by = list(exp$symbol), FUN = min, na.rm=T)
rownames(exp3) <- exp3$Group.1#加上行名
exp3 <- exp3[,-c(1,2,ncol(exp3))]#将多余列的数据剔除
write.csv(exp3, "exp_min.csv")#保存为csv格式








######第二种数据整合，利用下载下来的平台数据整合
##############################下面我们有两种处理一个探针应对多个基因的问题#####################
#第一种方式抽取多个基因中的第一个
ID <- data.frame(ID_REF = plate$ID, Gene_Symbol = plate$`Gene Symbol`)#将平台文件的ID列和SYMBOL列取出
ID$Gene_Symbol <-data.frame(sapply(ID$Gene_Symbol,function(x)unlist(strsplit(x,"///"))[1]),stringsAsFactors=F)[,1]
exp <- as.data.frame(exp)
exp$ID_REF <- rownames(exp)
exp <- merge(exp, ID, by='ID_REF')#merge()函数将dat1的探针id与芯片平台探针id相匹配，合并到dat1
exp[, grep("Gene_Symbol", colnames(exp))] <-  trimws(exp[, grep("Gene_Symbol", colnames(exp))])#去除数据头尾空格
exp[exp==""] <- NA#将空白负值NA
exp <- na.omit(exp)#删除GENE_SYBOL缺失的数据
exp <- as.data.frame(exp)
write.csv(exp, "exp.csv")
exp <- read.csv("exp.csv", row.names = 1)
exp[exp < 0] <- 0
#############几种处理重复基因的方式，下面的方式选择一种就行了##################
table(duplicated(exp$Gene_Symbol))#看一下有多少重复
#第一种，将重复基因取平均值
exp1 <- avereps(exp, ID = exp$Gene_Symbo)
exp1 <- as.data.frame(exp1)
rownames(exp1) <- exp1$Gene_Symbol#加上行名
exp1 <- exp1[,-c(1,ncol(exp1))]#将多余列的数据剔除
write.csv(exp1, "exp_average.csv")#保存为csv格式

#第二种，取重复基因中的最大值
exp2 <- aggregate(exp,by=list(exp$Gene_Symbol),FUN= max,na.rm=T)
rownames(exp2) <- exp2$Group.1#加上行名
exp2 <- exp2[,-c(1,2,ncol(exp2))]#将多余列的数据剔除
write.csv(exp2, "exp_max.csv")#保存为csv格式

#第三种，取重复基因中的最小值
exp3 <- aggregate(exp,by=list(exp$Gene_Symbol), FUN= min, na.rm=T)
rownames(exp3) <- exp3$Group.1#加上行名
exp3 <- exp3[,-c(1,2,ncol(exp3))]#将多余列的数据剔除
write.csv(exp3, "exp_min.csv")#保存为csv格式





#第二种方式将每一个基因都对应出来
ID <- data.frame(ID_REF = plate$ID, Gene_Symbol = plate$`Gene Symbol`)#将平台文件的ID列和SYMBOL列取出
x <- tibble(unlist(apply(ID,1,function(x){paste(x[1],str_split(x[2],'///',simplify=T),sep = "...")})))
colnames(x) <- "ABC"
file <- separate(x,ABC,c("ID_REF","Gene_Symbol"),sep = "\\...")#处理一个探针对应多个基因
exp <- as.data.frame(exp)#将表达矩阵转换为数据框
exp$ID_REF <- rownames(exp)
exp <- merge(exp, file, by = "ID_REF")#以ID为参照值，对表达矩阵和GPL进行合并
exp[, grep("Gene_Symbol", colnames(exp))] <-  trimws(exp[, grep("Gene_Symbol", colnames(exp))])#去除数据头尾空格
exp[exp == ""]<-NA#将空白负值NA
exp<-na.omit(exp)#删除GENE_SYBOL缺失的数据
exp <- as.data.frame(exp)
write.csv(exp, "exp.csv")
exp <- read.csv("exp.csv", row.names = 1)
exp[exp < 0] <- 0

#############几种处理重复基因的方式，下面的方式选择一种就行了##################
table(duplicated(exp$Gene_Symbol))#看一下有多少重复
#第一种，将重复基因取平均值
exp1 <- avereps(exp, ID = exp$Gene_Symbo)
exp1 <- as.data.frame(exp1)
rownames(exp1) <- exp1$Gene_Symbol#加上行名
exp1 <- exp1[,-c(1,ncol(exp1))]#将多余列的数据剔除
write.csv(exp1, "exp_average.csv")#保存为csv格式

#第二种，取重复基因中的最大值
exp2 <- aggregate(exp,by=list(exp$Gene_Symbol),FUN= max,na.rm=T)
rownames(exp2) <- exp2$Group.1#加上行名
exp2 <- exp2[,-c(1,2,ncol(exp2))]#将多余列的数据剔除
write.csv(exp2, "exp_max.csv")#保存为csv格式

#第三种，取重复基因中的最小值
exp3 <- aggregate(exp,by=list(exp$Gene_Symbol), FUN= min, na.rm=T)
rownames(exp3) <- exp3$Group.1#加上行名
exp3 <- exp3[,-c(1,2,ncol(exp3))]#将多余列的数据剔除
write.csv(exp3, "exp_min.csv")#保存为csv格式

